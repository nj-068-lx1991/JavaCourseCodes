## 模块九 分布式消息队列 总结

> 什么时候使用

	用于系统的物理解耦和逻辑解耦

> 场景

	削峰填谷
	数据驱动的任务依赖
	多个接收方，上游不关心多下游执行结果
	upsteam 关注结果但时间很长

> 消息队列的推送

> 推送 push

	优点
	实时性好
	中间件服务器做负载均衡
	缺点
	需要确认收到

> 拉取 pull

	优点
	可以拉取多条
	服务端逻辑少
	缺点:
	可能导致消息堆积
	消费端主动轮训

> rabbitmq的push和pull

	这种方式Api比较简单，但是需要自己控制拉取节奏。
	
> 消息不重复消费

	在消息中添加唯一的消息ID；同时确保消息的幂等性；

> 消息不丢

	消息发送的时候Producer要收到rabbitmq的Confirm消息；消费端收到消息后应该给rabbitmq发送ACK；

> 保证送达

	在保证消息不丢的前提下，在发送到rabbitmq之后写入数据库，当消息被consumer处理之后更新数据库
	中的状态；
	启动一个异步认为定时检查数据库中的任务，如果状态没有被更新就取出来重新发送到消息队列；
	在保证消息幂等性的前提下，可以保证消息被送达

> 消息顺序性

	消息中只有一个接收者的情况下，可以保证消息的顺序消费

> 消息队列的延时以及过期失效问题

	延时队列可以通过以下2种方式实现：

	 死信队列
	 延时消息
	 
> 限流

> 断线重连

> 高可用

> 主备

	只有主节点提供读写；备用节点只是在主节点挂掉的情况下服务；并发量并不大的情况可以使用haproxy
	做主备；

> 镜像模式

	mirror镜像队列；保证rabbitmq数据的高可靠性，实现数据同步2-3个节点的数据同步；前端需要自己做
	负载均衡
	
	
[分布式消息队列脑图](https://github.com/nj-068-lx1991/JavaCourseCodes/blob/master/week_15/%E6%AF%95%E4%B8%9A%E9%A1%B9%E7%9B%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png)